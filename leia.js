// Auto Page Turner para √Årvore/Leia SP
// Vers√£o otimizada para React SPAs

(function() {
    'use strict';
    
    // Configura√ß√µes
    const config = {
        interval: 5000, // Tempo entre p√°ginas em ms
        maxRetries: 3, // Tentativas de encontrar bot√£o
        waitForLoad: 1000, // Tempo de espera ap√≥s clicar
    };
    
    let autoTurnInterval;
    let isRunning = false;
    let controlPanel;
    let currentPage = 1;
    
    // Fun√ß√£o para aguardar elemento aparecer
    function waitForElement(selector, timeout = 5000) {
        return new Promise((resolve) => {
            const element = document.querySelector(selector);
            if (element) {
                resolve(element);
                return;
            }
            
            const observer = new MutationObserver(() => {
                const element = document.querySelector(selector);
                if (element) {
                    observer.disconnect();
                    resolve(element);
                }
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
            
            setTimeout(() => {
                observer.disconnect();
                resolve(null);
            }, timeout);
        });
    }
    
    // Fun√ß√£o para encontrar APENAS o bot√£o de pr√≥xima p√°gina (direita)
    function findNavigationButtons() {
        // Busca TODOS os bot√µes com caret e filtra o mais √† DIREITA
        const caretRightButtons = [];
        
        // Primeiro, coleta todos os bot√µes com caret-right
        const caretRightSpans = document.querySelectorAll('span[data-testid="bonsai-icon-caret-right"]');
        
        caretRightSpans.forEach(span => {
            const button = span.closest('button');
            if (button && !button.disabled && button.offsetParent !== null) {
                const rect = button.getBoundingClientRect();
                caretRightButtons.push({
                    button: button,
                    x: rect.left,
                    rect: rect
                });
            }
        });
        
        if (caretRightButtons.length === 0) {
            console.log('‚ùå Nenhum bot√£o caret-right encontrado');
            return null;
        }
        
        // Se h√° apenas um bot√£o caret-right, usa ele
        if (caretRightButtons.length === 1) {
            console.log('‚úÖ √önico bot√£o caret-right encontrado');
            return caretRightButtons[0].button;
        }
        
        // Se h√° m√∫ltiplos, pega o mais √† DIREITA (maior posi√ß√£o X)
        caretRightButtons.sort((a, b) => b.x - a.x);
        const rightmostButton = caretRightButtons[0];
        
        console.log(`‚úÖ Bot√£o mais √† direita selecionado (X: ${rightmostButton.x})`);
        console.log('Debug - Todos os bot√µes caret-right:');
        caretRightButtons.forEach((item, index) => {
            console.log(`  ${index}: X=${item.x}, Width=${item.rect.width}`);
        });
        
        return rightmostButton.button;
    }
    
    // Fun√ß√£o para virar p√°gina (com verifica√ß√£o extra)
    async function turnPage() {
        try {
            const nextButton = findNavigationButtons();
            
            if (nextButton) {
                // VERIFICA√á√ÉO FINAL: garantir que √© realmente o bot√£o da direita
                const rect = nextButton.getBoundingClientRect();
                const screenWidth = window.innerWidth;
                const isOnRightSide = rect.left > screenWidth * 0.5;
                
                if (!isOnRightSide) {
                    console.log('‚ö†Ô∏è Bot√£o n√£o est√° do lado direito da tela - cancelando');
                    return false;
                }
                
                // Aguarda um pouco para garantir estabilidade
                await new Promise(resolve => setTimeout(resolve, 200));
                
                // Simula clique real
                nextButton.focus();
                nextButton.click();
                
                // Dispara eventos adicionais para SPAs
                const clickEvent = new MouseEvent('click', {
                    view: window,
                    bubbles: true,
                    cancelable: true
                });
                nextButton.dispatchEvent(clickEvent);
                
                currentPage++;
                console.log(`‚úÖ P√°gina ${currentPage} - Avan√ßou (X: ${rect.left})`);
                updateControlPanel();
                
                // Aguarda o carregamento da nova p√°gina
                await new Promise(resolve => setTimeout(resolve, config.waitForLoad));
                return true;
            } else {
                console.log('‚ùå Bot√£o de pr√≥xima p√°gina n√£o encontrado');
                stopAutoTurn();
                return false;
            }
        } catch (error) {
            console.error('‚ùå Erro ao virar p√°gina:', error);
            return false;
        }
    }
    
    // Iniciar auto virada
    function startAutoTurn() {
        if (isRunning) return;
        
        isRunning = true;
        console.log(`Auto Page Turner iniciado (${config.interval/1000}s por p√°gina)`);
        
        // Primeira execu√ß√£o imediata
        setTimeout(() => {
            autoTurnInterval = setInterval(turnPage, config.interval);
        }, 1000);
        
        updateControlPanel();
    }
    
    // Parar auto virada
    function stopAutoTurn() {
        if (!isRunning) return;
        
        clearInterval(autoTurnInterval);
        isRunning = false;
        console.log('Auto Page Turner pausado');
        updateControlPanel();
    }
    
    // Criar painel de controle
    function createControlPanel() {
        const panel = document.createElement('div');
        panel.id = 'arvoreAutoPageTurner';
        panel.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            z-index: 999999;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 14px;
            min-width: 250px;
            backdrop-filter: blur(10px);
        `;
        
        panel.innerHTML = `
            <div style="margin-bottom: 15px; font-weight: bold; text-align: center; font-size: 16px;">
                üìñ Auto Leitor √Årvore
            </div>
            <div style="margin-bottom: 10px; text-align: center; opacity: 0.9;">
                P√°gina atual: <span id="currentPageDisplay">${currentPage}</span>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; font-size: 12px;">
                    Intervalo: <span id="intervalDisplay">${config.interval/1000}s</span>
                </label>
                <input type="range" id="intervalSlider" min="2000" max="20000" value="${config.interval}" step="1000" 
                       style="width: 100%; accent-color: white;">
            </div>
            <div style="text-align: center; display: flex; gap: 10px;">
                <button id="toggleButton" style="
                    background: rgba(255,255,255,0.2);
                    color: white;
                    border: 2px solid rgba(255,255,255,0.3);
                    padding: 10px 20px;
                    border-radius: 25px;
                    cursor: pointer;
                    font-weight: bold;
                    flex: 1;
                    transition: all 0.3s ease;
                ">‚ñ∂ Iniciar</button>
                <button id="testButton" style="
                    background: rgba(255,255,255,0.1);
                    color: white;
                    border: 2px solid rgba(255,255,255,0.2);
                    padding: 10px 15px;
                    border-radius: 25px;
                    cursor: pointer;
                ">üîÑ</button>
                <button id="closeButton" style="
                    background: rgba(255,0,0,0.3);
                    color: white;
                    border: 2px solid rgba(255,0,0,0.3);
                    padding: 10px 15px;
                    border-radius: 25px;
                    cursor: pointer;
                ">‚úï</button>
            </div>
        `;
        
        document.body.appendChild(panel);
        
        // Event listeners
        const toggleButton = panel.querySelector('#toggleButton');
        const testButton = panel.querySelector('#testButton');
        const closeButton = panel.querySelector('#closeButton');
        const intervalSlider = panel.querySelector('#intervalSlider');
        const intervalDisplay = panel.querySelector('#intervalDisplay');
        
        toggleButton.onclick = () => {
            if (isRunning) {
                stopAutoTurn();
            } else {
                startAutoTurn();
            }
        };
        
        testButton.onclick = () => {
            console.log('üîç Teste de navega√ß√£o - Buscando PR√ìXIMA p√°gina...');
            const button = findNavigationButtons();
            if (button) {
                console.log('‚úÖ Bot√£o PR√ìXIMA encontrado:', button);
                console.log('Classes:', button.className);
                console.log('Posi√ß√£o:', button.getBoundingClientRect());
                console.log('HTML (primeiros 200 chars):', button.innerHTML.substring(0, 200));
                
                // Verifica se realmente √© o bot√£o correto
                const isRightButton = button.innerHTML.includes('caret-right');
                const isNotLeftButton = !button.innerHTML.includes('caret-left');
                
                console.log('‚úÖ √â bot√£o direita?', isRightButton);
                console.log('‚úÖ N√ÉO √© bot√£o esquerda?', isNotLeftButton);
                
                if (isRightButton && isNotLeftButton) {
                    turnPage();
                } else {
                    console.log('‚ö†Ô∏è Bot√£o pode estar incorreto - n√£o clicando');
                }
            } else {
                console.log('‚ùå Bot√£o de PR√ìXIMA n√£o encontrado');
                
                // Debug: mostrar TODOS os bot√µes com caret
                const allCaretButtons = document.querySelectorAll('[data-testid*="caret"]');
                console.log('üîç Bot√µes com caret encontrados:', allCaretButtons.length);
                allCaretButtons.forEach((element, index) => {
                    const button = element.closest('button');
                    const testId = element.getAttribute('data-testid');
                    const rect = element.getBoundingClientRect();
                    console.log(`Caret ${index}: ${testId} - Posi√ß√£o X: ${rect.left} - Bot√£o:`, button?.className || 'sem bot√£o');
                });
            }
        };
        
        closeButton.onclick = () => {
            stopAutoTurn();
            panel.remove();
        };
        
        intervalSlider.oninput = (e) => {
            config.interval = parseInt(e.target.value);
            intervalDisplay.textContent = `${config.interval/1000}s`;
            
            if (isRunning) {
                stopAutoTurn();
                startAutoTurn();
            }
        };
        
        // Tornar o painel arrast√°vel
        let isDragging = false;
        let currentX = 0;
        let currentY = 0;
        let initialX = 0;
        let initialY = 0;
        
        panel.addEventListener('mousedown', (e) => {
            if (e.target === panel || e.target.closest('#arvoreAutoPageTurner > div:first-child')) {
                isDragging = true;
                initialX = e.clientX - currentX;
                initialY = e.clientY - currentY;
                panel.style.cursor = 'grabbing';
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                panel.style.transform = `translate(${currentX}px, ${currentY}px)`;
            }
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            panel.style.cursor = 'default';
        });
        
        return panel;
    }
    
    // Atualizar painel de controle
    function updateControlPanel() {
        if (!controlPanel) return;
        
        const toggleButton = controlPanel.querySelector('#toggleButton');
        const currentPageDisplay = controlPanel.querySelector('#currentPageDisplay');
        
        if (currentPageDisplay) {
            currentPageDisplay.textContent = currentPage;
        }
        
        if (isRunning) {
            toggleButton.innerHTML = '‚è∏ Pausar';
            toggleButton.style.background = 'rgba(255,165,0,0.3)';
        } else {
            toggleButton.innerHTML = '‚ñ∂ Iniciar';
            toggleButton.style.background = 'rgba(255,255,255,0.2)';
        }
    }
    
    // Verificar se j√° existe uma inst√¢ncia
    if (document.getElementById('arvoreAutoPageTurner')) {
        console.log('Auto Page Turner j√° est√° ativo');
        return;
    }
    
    // Aguardar o carregamento completo da aplica√ß√£o React
    setTimeout(() => {
        controlPanel = createControlPanel();
        console.log('üöÄ Auto Page Turner para √Årvore carregado!');
        console.log('üìñ Use o painel de controle para gerenciar a leitura autom√°tica');
        console.log('üîÑ Bot√£o de teste dispon√≠vel para verificar a navega√ß√£o');
    }, 2000);
    
})();
